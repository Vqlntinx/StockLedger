먼저 분할과 정복을 위해 도메인, 저장소, 서비스, UI를 각 모듈로 나눴고,
추상화는 TradeRepository와 StockTrade 같은 핵심 개념만 모델링하는 방식으로 적용했습니다.
캡슐화와 정보 은닉은 각 클래스 내부에서 데이터와 구현을 감추고, 필요한 인터페이스만 제공하도록 설계했습니다.
그리고 상속을 활용해 FileTradeRepository가 TradeRepository를 구현하게 하고,
다형성을 도입해 저장소나 손익 계산 로직을 전략 패턴을 통해 쉽게 교체할 수 있게 만들었습니다.

이러한 원리를 사용해서 시스템의 유지보수성과 확장성을 높이려고 했습니다.
-------------------------------
SOLID 원칙을 다음과 같이 적용했습니다.

SRP: StockTrade, StockService, FileTradeRepository, CLI 각각이
데이터 표현, 비즈니스 로직, 저장소, UI라는 단일 책임만 갖도록 분리했습니다.

OCP: TradeRepository와 RealizedPLCalculator를 중심으로
새 저장소 구현이나 새로운 손익 계산 방식을
‘기존 코드 수정 없이 클래스를 추가하는 방식’으로 확장할 수 있도록 설계했습니다.

LSP: TradeRepository를 구현하는 모든 저장소 클래스는
add와 listAll의 계약을 지켜서,
어디서든 부모 타입 대신 자식 타입을 넣어도 문제없이 동작하도록 만들었습니다.

ISP: TradeRepository 인터페이스에
꼭 필요한 메서드만 정의해서,
클라이언트가 쓰지 않는 기능에 의존하지 않도록 했습니다.

DIP: StockService가
FileTradeRepository 같은 구체 클래스가 아니라
TradeRepository와 RealizedPLCalculator 같은 추상 타입에 의존하게 해서,
상위 모듈이 하위 구현에 종속되지 않도록 설계했습니다.

이렇게 SOLID 원칙을 적용해서
코드가 읽기 쉽고, 변경에 강하고, 확장하기 편한 구조를 목표로 설계했습니다.
-----------------------------------
아키텍처는 레이어드 아키텍처 + 간단한 MVC 구조를 사용했습니다.
아까 말했다시피, 도메인, 서비스, 저장소, UI를 각각 별도의 모듈로 분리해서
주제를 나누고, 유지보수성을 높였습니다.

프레임워크는 Django 같은 무거운 웹 프레임워크 대신
Python 표준 라이브러리와 CLI만 사용을 했는데요,
그 이유는 이번 과제의 핵심이 프레임워크 사용이 아니라
소프트웨어 공학에 따른 설계 전반을 학습하는 것이라고 판단했습니다.

대신 디자인 패턴을 적절하게 사용해서
나중에 저장소나 손익 계산 방식을 바꾸더라도
상위 레이어를 수정하지 않고 확장할 수 있도록 확장성을 고려하여 설계했습니다.
------------------------------------
저장소 구조에 Repository 패턴을 적용했습니다.

TradeRepository라는 추상 인터페이스를 두고,
실제 저장은 FileTradeRepository가 담당합니다.

이 설계를 선택한 이유는 첫번째로 저장 방식이 JSON이든 DB든 나중에 얼마든지 교체할 수 있도록 하기 위해서입니다.
서비스 레이어는 오직 인터페이스에만 의존하므로 OCP, DIP를 자연스럽게 만족하게 됩니다. 두번째로는 단위 테스트 시에 파일에 의존하지 않고
InMemoryTradeRepository 같은 가짜 저장소로 빠르게 테스트하기 위해서입니다.
마지막 세번째로는 비즈니스 로직과 저장소 로직을 명확하게 분리하여
책임이 섞이지 않게 하기 위함입니다.

손익 계산에는 Strategy 패턴을 적용했는데요,

RealizedPLCalculator라는 전략 인터페이스를 두고,
현재는 평균단가 기반 전략만 구현했는데,
나중에 FIFO 방식, 세금 고려 방식 등
새로운 계산 전략을 쉽게 추가할 수 있도록 하려 했구요.

서비스 레이어는 계산 로직을 전혀 알 필요가 없고,
단지 인터페이스만 호출하기 때문에 DIP와 OCP를 만족합니다.

다시 말하자면, 손익 계산이라는 ‘변화 가능 요소’를
전략 클래스로 분리하여 확장성을 높인 설계라고 할 수 있겠습니다.
------------------------------------
분할과 정복 (Divide and Conquer)

먼저, 전체 기능을 한 파일이나 한 클래스에 몰아넣지 않고,
기능의 성격별로 모듈을 분리하는 분할과 정복 전략을 적용했습니다.

domain.py : 거래 데이터를 표현하는 도메인 객체
repository.py : 데이터 저장/로드 역할
service.py : 손익 계산과 같은 핵심 비즈니스 로직
cli.py : 사용자 인터페이스
main.py : 실행 시 진입점

이렇게 분리함으로써
각 컴포넌트가 맡는 책임을 명확히 하고, 문제를 작은 단위로 나누어 해결할 수 있었습니다.
-------------------------------------
추상화

추상화는 프로젝트에서 핵심 개념만을 모델링하고, 불필요한 세부 사항을 감추는 방식으로 적용했습니다.

그 예로, StockTrade 클래스는
주식 거래라는 개념을 날짜·종목명·수량·가격·유형으로 단순화했습니다.

또한, TradeRepository 인터페이스는
‘거래를 저장한다’와 ‘전체 거래 목록을 가져온다’라는 핵심 기능만 정의하고,
저장소 구현 방식(JSON 파일인지 DB인지)은 추상화하여 감췄습니다.
--------------------------------------
캡슐화

캡슐화는 객체가 자신의 데이터를 스스로 관리하도록 하는 설계 원리입니다.

저희는 각 클래스가

자신의 데이터를 내부 변수로 보관하고

외부에는 필요한 메서드만 노출하도록 설계했습니다.

예를 들어 FileTradeRepository는
파일 저장/로드에 필요한 내부 로직과 파일 경로를 모두 자신 내부에 숨기고,
외부에는 add()와 listAll() 두 개의 메서드만 제공하여
안전하면서도 일관된 인터페이스를 유지했습니다.
---------------------------------------
정보 은닉

정보 은닉은 단순히 데이터를 감추는 것을 넘어,
외부에서 알아서 안 되는 내부 구현을 숨기는 것에 초점을 둡니다.

손익 계산 방식은 RealizedPLCalculator 내부에서 처리되고,
외부에서는 계산 로직을 알 필요 없습니다.

파일 저장 경로나 JSON 포맷도
FileTradeRepository가 내부적으로 관리하여
외부 코드가 파일 구조를 몰라도 동작하도록 했습니다.

이렇게 함으로써, 내부 구현 변경이 외부 모듈에 영향을 주지 않는
‘느슨한 결합’을 달성했습니다.
----------------------------------------
상속

상속은 유사한 기능을 가진 클래스들이 공통된 인터페이스나 구조를 공유할 수 있도록 적용했습니다.

TradeRepository는 추상 클래스로,
그 아래 FileTradeRepository가 이를 상속받아 구현합니다.

상속을 활용한 덕분에,
향후에 DB 기반 저장소나 메모리 기반 저장소를 만들더라도
TradeRepository를 상속받기만 하면
서비스 로직을 고치지 않고도 저장 방식을 교체할 수 있습니다.
------------------------------------------
다형성 (Polymorphism)

다형성은 이번 프로젝트에서 두 가지 방식으로 활용했습니다.

1. Repository 다형성

TradeRepository 타입으로 객체를 바라보고,
실제 구현은 FileTradeRepository 객체를 전달합니다.

필요 시 SqlTradeRepository 같은 다른 구현체로 교체할 수 있습니다.

2. Strategy 패턴 기반 다형성

손익 계산 방식에 다형성을 적용했습니다.

RealizedPLCalculator 를 전략 인터페이스로 두고,
다른 방식의 계산기(예: FIFO 방식 계산기)를 만들어 교체할 수 있습니다.

이를 통해 서비스 계층은
‘어떤 방식으로 손익이 계산되는지’를 알 필요 없이
항상 동일한 인터페이스를 통해 계산 결과를 받습니다.